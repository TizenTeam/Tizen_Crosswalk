{{+bindTo:partials.standard_nacl_article}}
<h1>PPB_MediaStreamAudioTrack Struct Reference</h1>
<div>
<!-- Generated by Doxygen 1.7.6.1 -->


</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="PPB_MediaStreamAudioTrack" --><h2>
Data Fields</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a578685c385942e0f9e9e3b041dea4f17">IsMediaStreamAudioTrack</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a601dfa7dc958d6e0e33a667fe98cf087">Configure</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track, uint32_t samples_per_frame, uint32_t max_buffered_frames)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a54bbc279f3440f49fbb9ad357ba4d224">GetId</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a21037392fc0a6fb893881fddb204002f">HasEnded</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#af63b07a557e11a5bbee56a90b9071535">GetFrame</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> *frame, struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#aef0d773171eaaf01357982088795e3c4">RecycleFrame</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> frame)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a459bc28c5a626eb4a59a81286e9f8a58">Close</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track)</td></tr>
</table>
<hr /><h2>Field Documentation</h2>
<a class="anchor" id="a459bc28c5a626eb4a59a81286e9f8a58"></a><!-- doxytag: member="PPB_MediaStreamAudioTrack::Close" ref="a459bc28c5a626eb4a59a81286e9f8a58" args=")(PP_Resource audio_track)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void(* <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a459bc28c5a626eb4a59a81286e9f8a58">PPB_MediaStreamAudioTrack::Close</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Closes the MediaStream audio track and disconnects it from the audio source. </p>
<p>After calling <code><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a459bc28c5a626eb4a59a81286e9f8a58" title="Closes the MediaStream audio track and disconnects it from the audio source.">Close()</a></code>, no new frames will be received.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">audio_track</td><td>A <code>PP_Resource</code> corresponding to a MediaStream audio track resource. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a601dfa7dc958d6e0e33a667fe98cf087"></a><!-- doxytag: member="PPB_MediaStreamAudioTrack::Configure" ref="a601dfa7dc958d6e0e33a667fe98cf087" args=")(PP_Resource audio_track, uint32_t samples_per_frame, uint32_t max_buffered_frames)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t(* <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a601dfa7dc958d6e0e33a667fe98cf087">PPB_MediaStreamAudioTrack::Configure</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track, uint32_t samples_per_frame, uint32_t max_buffered_frames)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Configures underlying frame buffers for incoming frames. </p>
<p>If the application doesn't want to drop frames, then the <code>max_buffered_frames</code> should be chosen such that inter-frame processing time variability won't overrun the input buffer. If the buffer is overfilled, then frames will be dropped. The application can detect this by examining the timestamp on returned frames. If <code><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a601dfa7dc958d6e0e33a667fe98cf087" title="Configures underlying frame buffers for incoming frames.">Configure()</a></code> is not used, default settings will be used.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">audio_track</td><td>A <code>PP_Resource</code> corresponding to an audio resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">samples_per_frame</td><td>The number of audio samples in an audio frame. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_buffered_frames</td><td>The maximum number of audio frames to hold in the input buffer.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing a result code from <code><a class="el" href="pp__errors_8h.html" title="This file defines an enumeration of all PPAPI error codes.">pp_errors.h</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="af63b07a557e11a5bbee56a90b9071535"></a><!-- doxytag: member="PPB_MediaStreamAudioTrack::GetFrame" ref="af63b07a557e11a5bbee56a90b9071535" args=")(PP_Resource audio_track, PP_Resource *frame, struct PP_CompletionCallback callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t(* <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#af63b07a557e11a5bbee56a90b9071535">PPB_MediaStreamAudioTrack::GetFrame</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> *frame, struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> callback)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Gets the next audio frame from the MediaStream track. </p>
<p>If internal processing is slower than the incoming frame rate, new frames will be dropped from the incoming stream. Once the input buffer is full, frames will be dropped until <code><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#aef0d773171eaaf01357982088795e3c4" title="Recycles a frame returned by GetFrame(), so the track can reuse the underlying buffer of this frame...">RecycleFrame()</a></code> is called to free a spot for another frame to be buffered. If there are no frames in the input buffer, <code>PP_OK_COMPLETIONPENDING</code> will be returned immediately and the <code>callback</code> will be called, when a new frame is received or an error happens.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">audio_track</td><td>A <code>PP_Resource</code> corresponding to an audio resource. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">frame</td><td>A <code>PP_Resource</code> corresponding to an AudioFrame resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a></code> to be called upon completion of <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#af63b07a557e11a5bbee56a90b9071535" title="Gets the next audio frame from the MediaStream track.">GetFrame()</a>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing a result code from <code><a class="el" href="pp__errors_8h.html" title="This file defines an enumeration of all PPAPI error codes.">pp_errors.h</a></code>. Returns PP_ERROR_NOMEMORY if <code>max_buffered_frames</code> frames buffer was not allocated successfully. </dd></dl>
</div>
</div>
<a class="anchor" id="a54bbc279f3440f49fbb9ad357ba4d224"></a><!-- doxytag: member="PPB_MediaStreamAudioTrack::GetId" ref="a54bbc279f3440f49fbb9ad357ba4d224" args=")(PP_Resource audio_track)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>(* <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a54bbc279f3440f49fbb9ad357ba4d224">PPB_MediaStreamAudioTrack::GetId</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track)<code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Returns the track ID of the underlying MediaStream audio track. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">audio_track</td><td>The <code>PP_Resource</code> to check.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> containing the MediaStream track ID as a string. </dd></dl>
</div>
</div>
<a class="anchor" id="a21037392fc0a6fb893881fddb204002f"></a><!-- doxytag: member="PPB_MediaStreamAudioTrack::HasEnded" ref="a21037392fc0a6fb893881fddb204002f" args=")(PP_Resource audio_track)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(* <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a21037392fc0a6fb893881fddb204002f">PPB_MediaStreamAudioTrack::HasEnded</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Checks whether the underlying MediaStream track has ended. </p>
<p>Calls to GetFrame while the track has ended are safe to make and will complete, but will fail.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">audio_track</td><td>The <code>PP_Resource</code> to check.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>PP_Bool</code> with <code>PP_TRUE</code> if the given MediaStream track has ended or <code>PP_FALSE</code> otherwise. </dd></dl>
</div>
</div>
<a class="anchor" id="a578685c385942e0f9e9e3b041dea4f17"></a><!-- doxytag: member="PPB_MediaStreamAudioTrack::IsMediaStreamAudioTrack" ref="a578685c385942e0f9e9e3b041dea4f17" args=")(PP_Resource resource)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(* <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#a578685c385942e0f9e9e3b041dea4f17">PPB_MediaStreamAudioTrack::IsMediaStreamAudioTrack</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Determines if a resource is a MediaStream audio track resource. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">resource</td><td>The <code>PP_Resource</code> to test.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>PP_Bool</code> with <code>PP_TRUE</code> if the given resource is a Mediastream audio track resource or <code>PP_FALSE</code> otherwise. </dd></dl>
</div>
</div>
<a class="anchor" id="aef0d773171eaaf01357982088795e3c4"></a><!-- doxytag: member="PPB_MediaStreamAudioTrack::RecycleFrame" ref="aef0d773171eaaf01357982088795e3c4" args=")(PP_Resource audio_track, PP_Resource frame)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t(* <a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#aef0d773171eaaf01357982088795e3c4">PPB_MediaStreamAudioTrack::RecycleFrame</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> audio_track, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> frame)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Recycles a frame returned by <code><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#af63b07a557e11a5bbee56a90b9071535" title="Gets the next audio frame from the MediaStream track.">GetFrame()</a></code>, so the track can reuse the underlying buffer of this frame. </p>
<p>And the frame will become invalid. The caller should release all references it holds to <code>frame</code> and not use it anymore.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">audio_track</td><td>A <code>PP_Resource</code> corresponding to an audio resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>A <code>PP_Resource</code> corresponding to an AudioFrame resource returned by <code><a class="el" href="struct_p_p_b___media_stream_audio_track__0__1.html#af63b07a557e11a5bbee56a90b9071535" title="Gets the next audio frame from the MediaStream track.">GetFrame()</a></code>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing a result code from <code><a class="el" href="pp__errors_8h.html" title="This file defines an enumeration of all PPAPI error codes.">pp_errors.h</a></code>. </dd></dl>
</div>
</div>
<hr />The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ppb__media__stream__audio__track_8h.html">ppb_media_stream_audio_track.h</a></li>
</ul>
</div><!-- contents -->
{{/partials.standard_nacl_article}}
